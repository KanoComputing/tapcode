<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/app-layout/app-drawer/app-drawer.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../elements/tapcode-ide/tapcode-ide.html">
<link rel="import" href="../mixins/view-mixin.html">

<dom-module id="tapcode-challenge-view">
    <template>
        <style include="iron-flex iron-flex-alignment">  
            :host {
                display: block;
                height: 100%;
                width: 100%;
                background: #2b3035;
            }
            tapcode-ide {
                height: calc(100% - 56px);
                width: 100%;
            }
            .to-top {
                transition: transform 0.3s;
            }
            :host([fullscreen]) .to-top {
                transform: translateY(-100%);
            }
            .topbar {
                background-color: #33393d;
                padding: 0 16px;
            }
            #kano-logo {
                height: 18px;
                padding: 20px 0 18px;
            }
            #menu-icon {
                fill: rgba(255,255,255,0.25);
                vertical-align: middle;
            }
            #drawer {
                z-index: 20;
                --app-drawer-content-container: {
                    background: #2b3035;
                }
            }
            #drawer a:link,
            #drawer a:visited,
            #drawer a:hover,
            #drawer a:focus,
            #drawer a:active {
                display: block;
                text-decoration: none;
                color: #fff;
                outline: none;
            }
            #drawer .drawer-tab {
                text-align: left;
                padding-left: 24px;
                width: 100%;
                line-height: 56px;
                font-family: monospace;
                font-size: 16px;
                color: #fff;
                cursor: pointer;
            }
            .close-drawer>iron-icon {
                padding: 16px;
            }
            [hidden] {
                display: none !important;
            }
        </style>
        
        <div class="topbar horizontal layout center justified to-top">
            <img id="kano-logo" src="assets/kano.svg">
            <iron-icon id="menu-icon" icon="tapcode:menu" on-tap="_openDrawer"></iron-icon>
        </div>
        
        <app-drawer id="drawer" class="vertical layout" align="end">
            <div class="close-drawer" on-tap="_closeDrawer">
                <iron-icon id="menu-icon" icon="tapcode:close"></iron-icon>
            </div>
            <div class="drawer-tab" on-tap="_goPlayground">Playground</div>
            <div class="drawer-tab" on-tap="_openSave">Save</div>
            <a href="https://kano.me/" class="drawer-tab" target="_blank">More from Kano</a>
        </app-drawer>
              
        <tapcode-ide id="ide" on-change="_lineChanged" code="[[code]]" no-delete></tapcode-ide>
    </template>

    <script>

        class TapcodeChallengeView extends Kano.Tapcode.ViewMixin(Polymer.GestureEventListeners(Polymer.Element)) {
            static get is() { 
                return 'tapcode-challenge-view';
            }
      
            static get properties() {
                return {
                    tasks: {
                        type: Array,
                        linkState: 'challenge.tasks',
                        observer: 'onTasksSet'
                          
                    },
                    stepIndex: {
                        type: Number,
                        value: 0
                    },
                    task: {
                        type: Object,
                        computed: 'computeTask(taskIndex)',
                        observer: '_onTaskChanged'
                    },
                    taskIndex: {
                        type: Number
                    },
                    validators: {
                        type: Object,
                        value: () => {
                            return {}
                        }
                    }
                }
            }
    
            static get observers() {
                return [
                ]
            }
      
            constructor () {
                super();
                Polymer.RenderStatus.afterNextRender(this, () => {
                    this._addValidator('add-code', 'matchAddCode');
                    this._addValidator('param-change', 'matchParamChange');
                    this._addValidator('param-value', 'matchParamValue');
                });
            }
    
            _lineChanged (e) {
                if (!this.task || !this.task.validation) {
                    return;
                }
                this._checkEvent(this.task.validation, e.detail);
            }
    

    
            computeTask (taskIndex) {
                return this.tasks[taskIndex];
            }
    
            _onTaskChanged (task) {
                if (!task) {
                    return;
                }
                this.$.ide.$.editor.scrollLineToView(task.insert)
                    .then(() => {
                        this.$.ide.$.editor.addComment(task.insert, task.text, task.cursorPosition)
                    })
            }
            /**
             * Goes through all the defined validations and check them
             */
            _checkEvent (validation, detail) {
                Object.keys(validation).forEach((type) => {
                    if (type !== detail.type) {
                    } else {
                        if (this._validateEvent(validation[type], type, detail)) {
                            // TODO something like while if next step is also done
                            this.nextStep();
                        }
                        // The matching event didn't pass the checks, find a fallback
                        else {
                            // this._validateMatchFallback(validation[type], type, detail);
                        }
                    }
                });
            }
    
            nextStep () {
                this.taskIndex++;
            }
    
            _validateEvent (validation, type, detail) {
                if (this.validators[type] && this[this.validators[type]].call(this, validation, detail)) {
                    return true;
                }
            }
    
            _addValidator (type, method) {
                this.validators[type] = method;
            }
            
            arraysEqual (arr1, arr2) {
                if(arr1.length !== arr2.length)
                    return false;
                for (var i = arr1.length; i--;) {
                    if (arr1[i] !== arr2[i])
                        return false;
                }
                return true;
            }
            
            _openDrawer () {
                this.$.drawer.open();
            }
            
            _closeDrawer () {
                this.$.drawer.close();
            }
    
            matchAddCode (validation, detail) {
                if (validation.scope && !this.arraysEqual(detail.currentSegment.scope, validation.scope)) {
                    return;
                }
                if (typeof validation.paramIndex !== 'undefined' && validation.paramIndex !== detail.currentSegment.paramIndex) {
                    return;
                }
                return validation.name === detail.code.name;
            }
    
            matchParamChange (validation, event) {
                let paramIndex = event.currentSegment.paramIndex;
                let scope = event.currentSegment.scope[event.currentSegment.scope.length - 1];
                let realId = scope + '-' + paramIndex;
                return validation.id === realId;
            }
    
            matchParamValue (validation, event) {
                let paramIndex = event.currentSegment.paramIndex;
                // Take its own scope
                let scope = event.currentSegment.scope[event.currentSegment.scope.length - 1];
                let realId = scope + '-' + paramIndex;
                return validation.id === realId && validation.value === parseFloat(event.currentSegment.value);
            }
            
            _goPlayground () {
                console.log('open playground');
                this.dispatchEvent(
                    new CustomEvent('change-view', {
                        bubbles: true,
                        composed: true,
                        detail: 'editor'
                    })
                );
            }
            
            onTasksSet () {
                this.taskIndex = 0;
            }
        }
        customElements.define(TapcodeChallengeView.is, TapcodeChallengeView);
    </script>

</dom-module>
