<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">

<dom-module id="km-code-display">

  <template>

      <style is="custom-style" include="iron-flex iron-flex-alignment">

        :host {
            display: block;
            background-color: #2b3035;
            color: #fff;
            font-family: monospace;
            overflow: auto;
        }

        .line {
            padding-bottom: 12px;
        }

        .line-number {
            width: 16px;
            font-size: 12px;
            text-align: right;
            margin-right: 24px;
            cursor: pointer;
        }

        .line-segments {
            font-size: 12px;
        }

        .whitespace:before,
        .insertPoint:before,
        .lineEnd:before {
            content: '\00a0';
        }

        .indentation:before {
            content: '\00a0\00a0\00a0\00a0';
        }

        .parameter,
        .function {
            color: #7dc6ba;
        }

        .token {
            color: #e0915a;
        }

        .comma:after {
            content: '\00a0';
        }

        .highlight {
          background: #999;
        }

        .comment {
            opacity: 0.5;
        }

        [hidden] {
            display: none !important;
        }

      </style>
      <!-- shadow DOM-->
      <template id="line-repeater" is="dom-repeat" items="{{lines}}" as="line" index-as="lineIndex">
          <div class="line horizontal layout" on-tap="_selectLine">
              <span class="line-number" on-tap="_onLineNumberTapped">[[_getLineIndex(lineIndex)]]</span>
              <div class="line-segments horizontal layout">
                  <template id="segment-repeater" is="dom-repeat" items="{{line.segments}}" as="segment" index-as="segmentIndex">
                      <div id$="[[_computeEditableId(lineIndex, segmentIndex)]]"
                           class$="[[_calculateSegmentClass(segment.type, currentLine, currentSegment, lineIndex, segmentIndex)]]"
                           on-tap="_selectSegment">[[segment.value]]</div>
                  </template>
              </div>
          </div>
      </template>
  </template>

  <script>
  class KmCodeDisplay extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() {
        return 'km-code-display';
      }

      static get properties() {
        return {
          lines: {
              type: Array,
              value: () => []
          },
          currentLine: {
              type: Number,
              value: 0
          },
          currentSegment: {
              type: Number,
              value: 0
          },
          instanceTracker: {
              type: Object,
              value: () => {
                  return {};
              }
          },
          editingStarted: {
              type: Boolean,
              value: false,
              observer: '_onEditingStarted'
          },
          editedValue: {
              type: 'String',
              notify: true
          }
        }
      }

      static get observers() {
          return [
              '_onSegmentSelectionChanged(currentSegment, currentLine)',
              '_onLinesChanged(lines.*)'
          ]
      }

      constructor() {
          super();
          Polymer.RenderStatus.afterNextRender(this, () => {
              this.reset();
          });
      }

      getCode (beginning, end) {
          let lines;
          // It's okay if end is undefined for the last chunk
          if (beginning) {
              lines = this.lines.slice(beginning, end);
          } else {
              lines = this.lines;
          }

          let code = this.lines.reduce((code, l) => {
              let line = this.transformLine(l);
              return code + line + '\n';
          }, '')
          return code;
      }

      transformLine (line) {
          return line.segments.reduce((acc, s) => {
              if (s.type === 'comma') {
                  acc += ', ';
                  return acc;
              } else if (s.type === 'function') {
                // Wrapping up function in parenthesis
                acc = acc + '(' + s.value;
                return acc; 
              } else if (s.type === 'whitespace') {
                  acc += ' ';
              } else if (s.type === 'indentation') {
                  acc += '    ';
              } else if (s.value === '}' && /animate/.test(s.scope[s.scope.length -1])) {
                  // Special animate function case
                  acc += `Kano.TapCode.loop = requestAnimationFrame(animate)\n})();`;
                  return acc;
              }

              // Actually adding the value
              if (typeof s.value !== 'undefined' && s.type !== 'comma') {
                  acc += s.value;
              }
              return acc;
          }, '')
      }

      runCode () {
          this.dispatchEvent(
              new CustomEvent('run-code', {
                  bubbles: true,
                  composed: true,
                  detail: this.getCode()
              })
          );
      }

      typeComment (comment, lineNumber, segmentNumber) {
          setTimeout(() => {             
              this.set(`lines.${lineNumber}.segments.${segmentNumber}.value`, this.get(`lines.${lineNumber}.segments.${segmentNumber}.value`) + comment.shift());
              if (comment.length > 0) { 
                  this.typeComment(comment, lineNumber, segmentNumber);
              }
          }, 40)
      }; 

      addComment (lineNumber, comment) {
          if (this._getCurrentSegment() && this._getCurrentSegment().type === 'comment') {
              this._insertLine(0, 0);
              // this.moveLine();
          } else {
              this._insertLine(0, 0);
              // this.moveLine();
          }
          this.set(`lines.${lineNumber}.segments.${this.currentSegment}`,
              {
                  type: 'comment',
                  value: `// `,
                  scope: ['general']
              }
          );
          let commentArray = comment.split('');
          this.typeComment(commentArray, lineNumber, this.currentSegment);
          this.moveLine();
      }

      addCode (code) {
          let currentSegment = this._getCurrentSegment(),
              newLinesNeeded = code.lines.length - 1,
              currentScope = currentSegment.scope.concat([this._computeScopeId(code.name)]),
              insertPoint;

          // Cursor sits on existing code -> replace exisiting code
          if (currentSegment.handler) {
              this.deleteScope(currentSegment.scope[currentSegment.scope.length - 1]);
          }

          if (this.currentLine === this.lines.length - 1
              || this._doesLineCloseBlock(this.currentLine + 1)) {
              newLinesNeeded++;
          }

          // Cursor sits at end of line -> insert new line
          if (currentSegment.type === 'lineEnd') {
              this._insertLine(1);
              this.moveCursor();
              newLinesNeeded--;
          }
          
          // Insert new lines for code
          for (var i = 0; i < newLinesNeeded; i++) {
              this._insertLine(0, 1);
          }

          code.lines.forEach((line, index) => {

              // Clone the line
              line = JSON.parse(JSON.stringify(line));

              // Assign scope
              line.segments.forEach(segment => {
                  segment.scope = currentScope;

                  if (segment.type === 'parameter') {
                      segment.value = segment.defaultValue;
                  }
              });

              // Add semi-colon
              if (currentSegment.type !== 'parameter' && !currentSegment.returns
                  && code.type !== 'control') {
                  line.segments.push({ value: ';', type: 'token', scope: currentScope });
              }

              // Mark end of line
              if (line.segments[line.segments.length - 1].type !== 'insertPoint'
                      && this.currentSegment === this._getLineSegments().length - 1) {
                  line.segments.push({ type: 'lineEnd', scope: currentScope });
              }

              insertPoint = currentSegment.type === 'control' ? this.currentSegment - 2 : this.currentSegment;

              this.splice(`lines.${this.currentLine + index}.segments`, insertPoint, 1, ...line.segments);
          });
          this.notifyChange('add-code', { code });
          this.moveCursor();
      }

      notifyChange (type, data={}) {
          data.type = type;
          this.dispatchEvent(
              new CustomEvent('change', {
                  bubbles: true,
                  composed: true,
                  detail: data
              })
          );
      }

      reset () {
          this.set('lines', [{ segments: [{ type: 'insertPoint', scope: ['global'], editable: true }] }]);
          this.moveCursor();
      }

      moveCursor (direction = 1) {
          do {
              if (this._getLineSegments() && this._getLineSegments()[this.currentSegment + direction]) {
                  this.currentSegment = this.currentSegment + direction;
              } else {
                  this.moveLine(direction);
              }
          } while (!this._getCurrentSegment().editable);
      }

      moveLine (direction = 1) {
          if (this._getLineSegments(this.currentLine + direction)) {
              this.currentLine = this.currentLine + direction;
              this.currentSegment = (direction > 0) ? 0 : (this._getLineSegments().length - 1);
          } else {
              this.currentLine = direction === 1 ? 0 : this.lines.length - 1;
              this.currentSegment = 0;
          }
      }

      concludeEdit () {
          let currentSegment = this._getCurrentSegment();
          this.notifyChange('param-change', { currentSegment });
          this.moveCursor();
      }

      processInput (newValue) {
          const currentSegment = this._getCurrentSegment();
          if (!currentSegment) {
              return;
          }
          // Cursor sits on existing code -> replace exisiting code
          if (currentSegment.returns) {
              this.deleteScope(currentSegment.scope[currentSegment.scope.length - 1]);
              this.splice(`lines.${this.currentLine}.segments`, this.currentSegment, 0, {
                  type: 'parameter',
                  dataType: currentSegment.returns,
                  editable: true,
                  scope: currentSegment.scope
              });
          }

          //it's a color!
          if (isNaN(parseFloat(newValue))) {
              this.set(`lines.${this.currentLine}.segments.${this.currentSegment}.value`,
                      `"${newValue}"`);
              return;
          }

          //it's a number!
          this.editedValue = this.editingStarted ? currentSegment.value + newValue : newValue;
          this.set(`lines.${this.currentLine}.segments.${this.currentSegment}.value`,
                  this.editingStarted ? currentSegment.value + newValue : newValue);
          this.notifyChange('param-value', { currentSegment });
          this.editingStarted = true;
      }

      toggleOperator () {
          const currentSegmentValue = this._getCurrentSegment().value;
          if (currentSegmentValue[0] === '-') {
              this.set(`lines.${this.currentLine}.segments.${this.currentSegment}.value`,
                      currentSegmentValue.substr(1));
          } else {
              this.set(`lines.${this.currentLine}.segments.${this.currentSegment}.value`, '-' + currentSegmentValue);
          }
      }

      /**
      * Deletes code of a given scope starting from currentLine
      */

      deleteScope (scope) {
          let scopeArray,
            lineSegments,
            linesToDelete = [],
            segmentTypes;

          for (var i = this.currentLine; i < this.lines.length; i++) {
              lineSegments = this._getLineSegments(i);
              if (!lineSegments) {
                  break;
              }

              // Create an array of all scope values
              scopeArray = lineSegments.map(segment => segment.scope);
              scopeArray = [].concat.apply([], scopeArray);

              // Stop deleting if line is not in scope
              if (scopeArray.indexOf(scope) === -1) {
                  break;
              }

              // Delete segments with the given scope value starting from the end of a line
              for (var j = lineSegments.length - 1; j >= 0; j--) {
                  if (lineSegments[j].scope.indexOf(scope) !== -1)  {
                      this.splice(`lines.${i}.segments`, j, 1);
                  }
              }

              segmentTypes = lineSegments.filter(s => s.type !== 'indentation');
              if (segmentTypes.length === 0) {
                  linesToDelete.push(i);
              }
              // debugger;
          }

          for (var k = linesToDelete.length - 1; k >= 0; k--) {
              if (k !== 0) {
                  this.splice('lines', linesToDelete[k], 1);
              } else {
                  this.push(`lines.${linesToDelete[k]}.segments`, { type: 'insertPoint', scope: scopeArray, editable: true })
              }
          }

      }

      /*****************************
      * Event and observer callbacks
      ******************************/

      _selectSegment (e) {
          e.stopPropagation();
          // Update current selection
          e.currentTarget.id.replace(/(l)(\d*)(-s)(\d*)/, (match, p1, lineIndex, p2, segmentIndex) => {
              this.currentLine = parseInt(lineIndex);
              this.currentSegment = parseInt(segmentIndex);
          });
          while (!this._getCurrentSegment().editable) {
              this.moveCursor();
          }
      }

      _selectLine (e) {
          this.currentLine = e.model.lineIndex;
          this.currentSegment = this.lines[this.currentLine].segments.length - 1;
      }

      _onLineNumberTapped (e) {
          this.currentLine = e.model.lineIndex;
          let copyFrom = this._doesLineCloseBlock(this.currentLine) ? -1 : 0;
          this._insertLine(copyFrom, 0);
      }

      _insertLine (from, to) {
          let lineIndex = this.currentLine + from,
              lineCopy = JSON.parse(JSON.stringify(this.lines[lineIndex])),
              allScope = lineCopy.segments.map(segment => segment.scope),
              currentScope = [].concat.apply([], allScope);
          currentScope = this._dedupArray(currentScope);
          if (typeof to === 'undefined') {
              to = from;
          }

          for (var j = lineCopy.segments.length - 1; j >= 0; j--) {
              if (lineCopy.segments[j].type !== 'indentation') {
                  lineCopy.segments.splice(j, 1);
              }
          }
          lineCopy.segments.push({ type: 'insertPoint', scope: currentScope, editable: true });  
          this.splice('lines', this.currentLine + to, 0, lineCopy)
      }

      _onSegmentSelectionChanged () {
          const selected = this._getCurrentSegment();
          this.editingStarted = false;
          if (!selected || (!selected.editable && selected.type !== 'lineEnd')) {
              return;
          }
          this.dispatchEvent(
              new CustomEvent('edit-request', {
                  bubbles: true,
                  composed: true,
                  detail: selected
              })
          );

          if (typeof selected.value !== 'undefined') {
              this.editedValue = selected.value;
          }
      
      }
      _onEditingStarted (started) {
          if (started) {

          }
      }

      _onLinesChanged () {
          this._debouncer = Polymer.Debouncer.debounce(
             this._debouncer,
             Polymer.Async.timeOut.after(20),
             this.runCode.bind(this)
          );

      }

      /******************
      * Data-bind helpers
      *******************/

      _calculateSegmentClass (type, currentLine, currentSegment, lineIndex, segmentIndex) {
          if (currentLine === lineIndex && currentSegment === segmentIndex) {
              return `segment ${type} highlight`;
          } else {
              return `segment ${type}`;
          }
      }

      _computeEditableId (lineIndex, segmentIndex) {
          return `l${lineIndex}-s${segmentIndex}`
      }

      _getLineIndex (index) {
          return index + 1;
      }

      /****************
      * Private helpers
      ******************/

      _computeScopeId (name) {
          this.instanceTracker[name] = this.instanceTracker[name] || 0;
          this.instanceTracker[name]++;
          return `${name}-${this.instanceTracker[name]}`;
      }

      _getLineSegments (lineIndex=this.currentLine) {
          return this.get(`lines.${lineIndex}.segments`);
      }

      _doesLineCloseBlock (index) {
          let endingTokens = this.lines[index].segments.filter(s => s.value === '}');
          return Boolean(endingTokens.length);
      }

      _getInsertPoint() {
          return { type: 'insertPoint', scope: this._getCurrentSegment().scope, editable: true };
      }

      _dedupArray (arr) {
          return [...new Set(arr)];
      }

      _getCurrentSegment () {
          const lineSegments = this._getLineSegments();
          if (!lineSegments) {
              return;
          }
          return lineSegments[this.currentSegment];
      }

    }

    customElements.define(KmCodeDisplay.is, KmCodeDisplay);
  </script>
</dom-module>