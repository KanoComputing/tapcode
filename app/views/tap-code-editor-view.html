<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../bower_components/kwc-color-picker/kwc-color-picker.html">
<link rel="import" href="../elements/km-code-display/km-code-display.html">
<link rel="import" href="../elements/km-softkeys/km-softkeys.html">

<dom-module id="tap-code-editor-view">

    <template>
  
      <style is="custom-style" include="iron-flex iron-flex-alignment">
  
        :host {
            display: flex;
            flex-direction: column;
            /*justify-content: space-between;*/
            height: 100%;
            width: 100%;
            box-sizing: border-box;
            background-color: #33393d;
            color: #fff;
            font-size: 12px;
            font-family: monospace;
            font-weight: bold;
            /*border: 1px solid yellow;*/
        }

        .topbar {
            background-color: #33393d;
            padding: 0 14px;
        }

        #kano-logo {
            height: 18px;
            padding: 12px 0 10px;
        }

        .code-and-canvas {
            height: 55vh;
            position: relative;
            top: 0;
            left: 0;
        }

        .controls {
            /*height: calc(55vh - 43px);*/
        }

        #code {
            display: block;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            color: #fff;
            overflow: scroll;
            box-sizing: border-box;
            padding: 24px 16px;
            background: transparent;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .clear-and-refresh {
            position: absolute;
            top: 24px;
            right: 24px;
        }

        .clear-and-refresh>div {
            display: inline-block;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.3s ease-in;
        }

        .clear-and-refresh>div:first-of-type {
            margin-right: 8px;
        }

        .clear-and-refresh>div:hover {
            opacity: 1;
        }

        .left-and-right-arrow {
            position: absolute;
            bottom: 24px;
            right: 24px;
            height: 40px;
            width: 100px;
        }

        .arrow {
            display: inline-block;
            cursor: pointer;
            background-color: #33393d;
            padding: 12px 16px 10px;
        }

        .arrow > img {
            width: 12px;
            margin: 0;
        }

        #left-arrow {
            transform: rotate(180deg);
        }
  
        .code-line {
            min-height: 26px;
        }

        kwc-color-picker#color-input {
            --kwc-color-picker-margin: 16px;
            margin: 0 auto;
            --kwc-color-picker-size: 32px;
        }        

        #toolbox {
            padding: 24px 16px 16px;
            overflow: scroll;
            box-sizing: border-box;
            position: relative;
        }

        .toolbox-bar {
            width: 100%;
            /*height: 5vh;*/
            background-color: #33393d;
            border-bottom: 1px solid #2b3035;
            box-sizing: border-box;
            padding: 0 16px;
            flex-shrink: 0;
        }

        .toolbox-tab {
            display: inline-block;
            padding: 14px 0 12px;
            text-align: center;
            color: #ffffff;
            font-family: monospace;
        }

        .toolbox-tab.selected {
            text-decoration: underline;
        }

        .menu-selected {
            text-decoration: underline;
        }

        .toolbox-item {
            background-color: #23272b;
            color: #fff;
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            padding: 10px 10px 8px;
            margin: 0 8px 16px 0;
        }

        .whitespace:before {
            content: '\00a0';
        }

        .comma:after {
            content: '\00a0';
        }

        [disabled] {
            opacity: 0.5;
            pointer-events: none;
        }

        [hidden] {
            display: none !important;
        }
  
      </style>
      
      <div class="topbar">
          <img id="kano-logo" src="assets/kano.svg">
      </div>
      <div class="code-and-canvas">
          <canvas id="canvas" width="400" height="400"></canvas>
          <km-code-display id="code" on-edit-request="_onEditRequest" edited-value="{{editedValue}}" on-run-code="runCode" on-change="_lineChanged"></km-code-display>
  
          <div class="clear-and-refresh">
              <div on-tap="clearCode">C</div>
              <div on-tap="resetCanvas">R</div>
          </div>
          <div class="left-and-right-arrow">
              <div class="arrow" on-tap="_moveLeft">
                  <img id="left-arrow" src="assets/arrow.svg"></img>
              </div>
              <div class="arrow" on-tap="_moveRight">
                  <img src="assets/arrow.svg"></img>
              </div>
          </div>
  
      </div>
      <div class="controls layout vertical flex">
          <div class="toolbox-bar layout horizontal center" hidden$="[[!_isEqual(inputType, 'newCode')]]">
              <div class$="[[_computeTabClass(activeTab, 'drawing')]]" data-value="drawing" on-tap="_selectMenuTab">drawing</div>
              <div class$="[[_computeTabClass(activeTab, 'style')]]" data-value="style" on-tap="_selectMenuTab">style</div>
              <div class$="[[_computeTabClass(activeTab, 'control')]]" data-value="control" on-tap="_selectMenuTab">control</div>
          </div>
          <div class="toolbox-bar layout horizontal center" hidden$="[[_isEqual(inputType, 'newCode')]]">
              <div class$="[[_computeTabClass(activeTab, 'expressions')]]" data-value="expressions" on-tap="_selectMenuTab">code</div>
              <div class$="[[_computeTabClass(activeTab, inputType)]]" data-value$="[[inputType]]" on-tap="_selectMenuTab">[[inputType]]</div>
          </div>
          <div class="toolbox-bar layout horizontal center" hidden$="[[!_needNumberControl(activeTab, showNumberControl)]]">
              <div class="toolbox-tab flex" on-tap="_toggleOperator" disabled$="[[!needOperator]]">[[operator]]</div>
              <div class="toolbox-tab flex" on-tap="spliceValue" disabled$="[[!needNumberDelete]]"><-</div>
          </div>
          <km-softkeys id="number-input" class="flex" hidden$="[[!_isEqual(activeTab, 'number')]]" on-key-tapped="_processInput"></km-softkeys>
          <kwc-color-picker id="color-input" class="flex" hidden$="[[!_isEqual(activeTab, 'color')]]" row-size="5" on-change="_processInput"></kwc-color-picker>
          <div id="toolbox" class="flex layout horizontal start start-aligned wrap" hidden$="[[!_needCodeTray(inputType, activeTab)]]">
              <template id="menu-item-repeater" is="dom-repeat" items="{{statements}}" as="statement" filter="_filterMenuItem">
                  <div class="toolbox-item horizontal layout" on-tap="_addStatement">
                      <template id="line-repeater" is="dom-repeat" items="{{statement.lines}}" as="line">
                          <div class="horizontal layout">
                              <template id="segment-repeater" is="dom-repeat" items="{{line.segments}}" as="segment">
                                  <div class$="[[_calculateSegmentClass(segment.type)]]">[[segment.value]]</div>
                              </template>
                          </div>
                      </template>
                  </div>
              </template>
          </div>
      </div>
    </template>

    <script>

      class TapCodeEditorView extends Polymer.GestureEventListeners(Polymer.Element) {
        static get is() { 
            return 'tap-code-editor-view';
        }
  
        static get properties() {
            return {
                activeTab: {
                    type: String,
                    value: 'drawing'
                },
                inputType: {
                    type: String,
                    value: 'newCode'
                },
                colorKeys: {
                    type: Array,
                    value: () => ['#ff0000','#00ff00','#0000ff','#ffff00','#00ffff','#ff00ff','#ffffff','#000000','#7f7f7f']
                },
                operator: {
                    type: String,
                    value: "-"
                },
                showNumberControl: {
                    type: Boolean,
                    value: false
                },
                editedValue: {
                    type: String,
                    observer: '_onEditedValueChanged'
                },
                needNumberDelete: {
                    type: Boolean,
                    value: false
                },
                needOperator: {
                    type: Boolean,
                    value: false
                },
                steps: {
                    type: Array,
                    value: () => []
                },
                step: {
                    type: Object,
                    value: () => {
                        return {}
                    }
                },
                stepIndex: {
                    type: Number,
                    value: 0
                },
                task: {
                    type: Object,
                    computed: 'computeTask(taskIndex)',
                    observer: '_onTaskChanged'
                },
                taskIndex: {
                    type: Number
                },
                validators: {
                    type: Object,
                    value: () => {
                        return {}
                    }
                }
            }
        }

        static get observers() {
            return [
                '_onStepsChanged(steps)',
                '_onStepChanged(step)'
            ]
        }
  
        constructor () {
            super();
            Polymer.RenderStatus.afterNextRender(this, () => {
                this.processApiStatements(Kano.TapCode.api);
                this._addValidator('add-code', 'matchAddCode');
                this._addValidator('param-change', 'matchParamChange');
                this._addValidator('param-value', 'matchParamValue');
                this.loadChallenge();
            });
        }

        flattenTasks (steps) {
            let tasks;
            return [].concat.apply([], steps.map(s => {
                return s.instructions.map(i => {
                    // Marking the insertPoint of each instruction
                    // Return one item of the flattened array
                    return i;
                });
            }));
        }

        runCode (e) {
            if (this.CanvasDraw) {
                this.CanvasDraw.runCode(e.detail);
            }
        }

        _onStepsChanged (steps) {
            if (!steps) {
                return;
            }
            this.step = steps[1];
        }

        _onStepChanged (step) {
            // this.task = step.instructions
        }

        computeSelectedStep () {

        }

        computeTask (taskIndex) {
            return this.tasks[taskIndex];
        }

        _onTaskChanged (task) {
            console.log('task', task)
            this.$.code.addComment(task.insert, task.text)
        } 

        processApiStatements (statements) {
            let opts = {};
            opts.statements = Kano.TapCode.api;
            opts.ctx = this.$.canvas.getContext("2d");
            opts.canvas = this.$.canvas;
            let canvasOpts = {};
            canvasOpts.ctx = this.$.canvas.getContext("2d");
            canvasOpts.canvas = this.$.canvas;
            this.CanvasDraw = new Kano.CanvasDraw(canvasOpts);
            this.prism = new Kano.Prism(opts);
            this.set('statements', this.prism.statements);
            setTimeout(() => {
                // this.$.code.addCode(this.statements[2]);
                // this.$.code.moveLine();
                // this.$.code.addCode(this.statements[3]);
            }, 100);
        }
  
        ready () {
            super.ready();
            Polymer.RenderStatus.afterNextRender(this, function() {
                resetCanvas();
            });
        }  
  
        _onEditRequest (e) {
            let dataType = e.detail.dataType || e.detail.returns;
            if (dataType) {
                this.inputType = this.activeTab = dataType;
            } else {
                this.inputType = 'newCode';
                this.activeTab = 'drawing';
            }
            this.$['menu-item-repeater'].render();
        }
  
        _addStatement (e) {
            this.$.code.addCode(e.model.statement);
        }
  
        _processInput (e) {
            if (e.detail === 'done') {
                this.$.code.concludeEdit();
            } else {
                this.$.code.processInput(e.detail);
            }
        }
  
        _selectMenuTab (e) {
            this.activeTab = e.currentTarget.getAttribute('data-value');
            this.$['menu-item-repeater'].render();
        }
  
        _filterMenuItem (item) {
            if (this.inputType === 'newCode') {
                return item.type === this.activeTab;
            } else {
                return item.returns === this.inputType;
            }
        }
  
        _isEqual (selected, instance) {
            this.$['color-input'].notifyResize();
            return selected === instance;
        }

        loadChallenge () {
            let creation,
                steps;

            fetch(`/assets/challenges/challenge-no1/challenge-no1.json`)
                .then(r => r.json())
                .then(data => {
                    this.steps = data.steps;
                    this.tasks = this.flattenTasks(this.steps);
                    this.taskIndex = 0;
                    this.steps.forEach((step, index, steps) => {
                        // TODO Be ready for multi-line instructions
                        // this.$.code.addComment(step.insert, step.instructions[0]);
                    });
                });
    
            // fetch(`/assets/challenges/challenge-no1/challenge-no1.tapcode`)
            //     .then(r => r.json())
            //     .then(data => {
            //         creation = data;
            //         this.$.code.set('lines', creation);

            //     });
        }

        exportCode () {
            let a = document.createElement('a'),
                file = new Blob([JSON.stringify(this.$.code.lines)], {type: 'application/taptype'}),
                url = URL.createObjectURL(file);
            document.body.appendChild(a);
            a.download = 'my-code.tapcode';
            a.href = url;
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        _importCode () {
            this.fileInput = document.createElement('input');
            this.fileInput.setAttribute('type', 'file');
            this.fileInput.style.display = 'none';
            this.fileInput.addEventListener('change', evt => {
                let f = evt.target.files[0];
                if (f) {
                    let r = new FileReader();
                    r.onload = (e) => {
                        // Read the mode
                        let code = JSON.parse(e.target.result);
                        this.$.code.set('lines', code);
                    };
                    r.readAsText(f);
                    document.body.removeChild(this.fileInput);
                }
            });
            document.body.appendChild(this.fileInput);
            this.fileInput.click();
        }
  
        _moveLeft () {
            this.$.code.moveCursor(-1);
        }
  
        _moveRight () {
            this.$.code.moveCursor(1);
        }

        _toggleOperator () {
            this.$.code.toggleOperator();
            this.operator = this.operator === '-' ? '+' : '-';
        }
  
        clearCode () {
            this.resetCanvas();
            if (Kano.TapCode.loop) {
                window.cancelAnimationFrame(Kano.TapCode.loop);
                Kano.TapCode.loop = null;
            }
            this.$.code.reset();
        }

        resetCanvas () {
            resetCanvas();
        }

        spliceValue () {
            //TODO refactor
            let ed = this.$.code;
            let currentValue = ed.get(`lines.${ed.currentLine}.segments.${ed.currentSegment}.value`);
            ed.set(`lines.${ed.currentLine}.segments.${ed.currentSegment}.value`, currentValue.slice(0, -1));
            this.editedValue = currentValue.slice(0, -1);
        }

        _needNumberControl (activeTab, showNumberControl) {
            return activeTab === 'number' && showNumberControl;
        }

        _onEditedValueChanged (value) {
            this.showNumberControl = !isNaN(parseFloat(value));
            if (!isNaN(parseFloat(value))) {
                this.showNumberControl = true;
                this.needNumberDelete = value.length > 1;
                this.needOperator = value !== '0';
                this.operator = value < 0 ? '+' : '-' 
            }
        }

        _needCodeTray (inputType, activeTab) {
            return (inputType === 'newCode' || activeTab === 'expressions');
        }

        _computeTabClass (activeTab, instance) {
            return activeTab === instance ? 'toolbox-tab flex selected' : 'toolbox-tab flex';
        }

        _calculateSegmentClass (type) {
            return `segment ${type}`;
        }

        /**
         * Goes through all the defined validations and check them
         */
        _checkEvent (validation, detail) {
            console.log('check event')
            Object.keys(validation).forEach((type) => {
                if (type !== detail.type) {
                    console.log('wrong type');
                } else {
                    if (this._validateEvent(validation[type], type, detail)) {
                        // TODO something like while if next step is also done
                        this.nextStep();
                    }
                    // The matching event didn't pass the checks, find a fallback
                    else {
                        // this._validateMatchFallback(validation[type], type, detail);
                    }
                }
            });
        }

        nextStep () {
            console.log('next step YO')
            this.taskIndex++;
        }

        _validateEvent (validation, type, detail) {
            if (this.validators[type] && this[this.validators[type]].call(this, validation, detail)) {
                return true;
            }
        }

        _lineChanged (e) {
            if (!this.task || !this.task.validation) {
                return;
            }
            this._checkEvent(this.task.validation, e.detail);
        }

        _addValidator (type, method) {
            this.validators[type] = method;
        }

        notifyChange (type, data={}) {
            data.type = type;
            this.dispatchEvent(
                new CustomEvent('change', {
                    bubbles: true,
                    composed: true,
                    detail: data
                })
            );
        }

        matchAddCode (validation, event) {
            return validation.name === event.code.name;
        }

        matchParamChange (validation, event) {
            let paramIndex = event.currentSegment.paramIndex;
            let scope = event.currentSegment.scope[event.currentSegment.scope.length - 1];
            let realId = scope + '-' + paramIndex;
            return validation.id === realId;
        }

        matchParamValue (validation, event) {
            let paramIndex = event.currentSegment.paramIndex;
            let scope = event.currentSegment.scope[event.currentSegment.scope.length - 1];
            let realId = scope + '-' + paramIndex;
            return validation.id === realId && validation.value === event.currentSegment.value;
        }

      }
      customElements.define(TapCodeEditorView.is, TapCodeEditorView);
    </script>

</dom-module>

